#!/usr/bin/env python3
"""
BMW N54 Multi-Version Offset Database - Software-Specific Map Offsets
======================================================================

Author: Gregory King
Date: November 3, 2025
License: GNU General Public License v3.0 (GPL-3.0)

Description:
    Multi-version offset database for BMW N54 ECU map patching.
    Automatically selects correct offsets based on detected software ID
    from ECU binary file.

Supported Software IDs:
    - I8A0S: Common in various N54 applications
    - INA0S: Common in US-market 335i
    - IJE0S: Common in EU-market 335i
    - IKM0S: Common in 135i

All offsets extracted from TunerPro XDF definitions (dmacpro91/BMW-XDFs repo).

Features:
    - Automatic software ID detection from binary
    - Version-specific offset lookup
    - VMAX, RPM limiter, and DTC offsets
    - Extensible for additional software versions

Classes:
    OffsetEntry - Individual offset definition
    OffsetDatabase - Main offset database manager

Functions:
    detect_software_id(bin_data: bytearray) -> Optional[str]
    get_offset_database() -> OffsetDatabase
    get_vmax_offsets(software_id: str) -> List[int]
    get_rev_limiter_offsets(software_id: str) -> List[int]
    get_dtc_offsets(software_id: str) -> List[int]

Variables (Module-level):
    _offset_db: OffsetDatabase - Singleton database instance
"""

from dataclasses import dataclass
from typing import Dict, List, Optional
from pathlib import Path
import json


@dataclass
class OffsetEntry:
    """Single offset entry with metadata."""
    offset: int
    size_bytes: int
    title: str
    units: str = ""
    description: str = ""


class OffsetDatabase:
    """Database of ECU map offsets for multiple software versions."""
    
    # Load offset database from JSON (generated by parse_xdf_offsets.py)
    _DATABASE_PATH = Path(__file__).parent.parent / 'maps' / 'xdf_definitions' / 'offset_database.json'
    
    # Supported software IDs
    SUPPORTED_SOFTWARE_IDS = ['I8A0S', 'INA0S', 'IJE0S', 'IKM0S']
    
    def __init__(self):
        """Load offset database from JSON file."""
        self._db = {}
        if self._DATABASE_PATH.exists():
            with open(self._DATABASE_PATH) as f:
                data = json.load(f)
                for sw_data in data:
                    sw_id = sw_data['software_id']
                    self._db[sw_id] = sw_data['features']
    
    def get_vmax_offsets(self, software_id: str) -> List[OffsetEntry]:
        """
        Get VMAX (speed limiter) offsets for software version.
        
        Args:
            software_id: ECU software ID (e.g., 'I8A0S')
            
        Returns:
            List of OffsetEntry for VMAX tables
        """
        return self._get_offsets(software_id, 'vmax', [
            'Speed Limiter (Master)',
            'Speed Limiter',
        ])
    
    def get_rev_limiter_offsets(self, software_id: str) -> List[OffsetEntry]:
        """
        Get RPM limiter offsets for software version.
        
        Args:
            software_id: ECU software ID (e.g., 'I8A0S')
            
        Returns:
            List of OffsetEntry for rev limiter tables
        """
        return self._get_offsets(software_id, 'rev_limiter', [
            'Rev Limit by Gear Floor (AT)',
            'Rev Limit by Gear Floor (MT)',
            'Rev Limit by Gear Ceiling (AT)',
            'Rev Limit by Gear Ceiling (MT)',
            'Rev Limit (Clutch Pressed)',
        ])
    
    def get_dtc_offsets(self, software_id: str) -> List[OffsetEntry]:
        """
        Get DTC (diagnostic trouble code) offsets for software version.
        
        Args:
            software_id: ECU software ID (e.g., 'I8A0S')
            
        Returns:
            List of OffsetEntry for DTC tables
        """
        return self._get_offsets(software_id, 'dtc', [
            'DTC Master',
        ])
    
    def get_burbles_offsets(self, software_id: str) -> List[OffsetEntry]:
        """
        Get burbles/pops offsets for software version.
        
        Args:
            software_id: ECU software ID (e.g., 'I8A0S')
            
        Returns:
            List of OffsetEntry for burbles tables
        """
        return self._get_offsets(software_id, 'burbles', [
            'Burble Ignition Timing',
            'Burble Duration (Normal)',
        ])
    
    def get_boost_ceiling_offsets(self, software_id: str) -> List[OffsetEntry]:
        """
        Get boost ceiling offsets for software version.
        
        Args:
            software_id: ECU software ID (e.g., 'I8A0S')
            
        Returns:
            List of OffsetEntry for boost ceiling tables
        """
        return self._get_offsets(software_id, 'boost', [
            'Boost Ceiling',
        ])
    
    def _get_offsets(self, software_id: str, feature: str, 
                    titles: List[str]) -> List[OffsetEntry]:
        """
        Internal method to extract specific offsets from database.
        
        Args:
            software_id: ECU software ID
            feature: Feature category ('vmax', 'rev_limiter', etc.)
            titles: List of table titles to extract
            
        Returns:
            List of matching OffsetEntry objects
        """
        if software_id not in self._db:
            raise ValueError(f"Unsupported software ID: {software_id}. "
                           f"Supported: {', '.join(self.SUPPORTED_SOFTWARE_IDS)}")
        
        features = self._db[software_id].get(feature, [])
        results = []
        
        for title in titles:
            matching = [e for e in features if e['title'] == title]
            if matching:
                entry_data = matching[0]
                results.append(OffsetEntry(
                    offset=entry_data['offset_int'],
                    size_bytes=entry_data['size_bytes'],
                    title=entry_data['title'],
                    units=entry_data.get('units', ''),
                    description=entry_data.get('description', ''),
                ))
        
        return results
    
    def compare_offsets(self, feature: str, title: str) -> Dict[str, Optional[int]]:
        """
        Compare offset locations across all software versions.
        
        Args:
            feature: Feature category ('vmax', 'rev_limiter', etc.)
            title: Table title to compare
            
        Returns:
            Dict mapping software_id -> offset (or None if not found)
        """
        results = {}
        for sw_id in self.SUPPORTED_SOFTWARE_IDS:
            features = self._db.get(sw_id, {}).get(feature, [])
            matching = [e for e in features if e['title'] == title]
            if matching:
                results[sw_id] = matching[0]['offset_int']
            else:
                results[sw_id] = None
        return results
    
    def validate_software_id(self, software_id: str) -> bool:
        """
        Check if software ID is supported.
        
        Args:
            software_id: ECU software ID to validate
            
        Returns:
            True if supported, False otherwise
        """
        return software_id in self.SUPPORTED_SOFTWARE_IDS


def detect_software_id(bin_data: bytearray) -> Optional[str]:
    """
    Detect BMW software ID from .bin file data.
    
    BMW stores software ID as ASCII string in the calibration data.
    Common locations and patterns:
    - Format: "I8A0S", "INA0S", "IJE0S", "IKM0S"
    - Usually in first 256KB
    - 5 characters: I or J + 3 alphanumerics + S
    
    Args:
        bin_data: Binary data from .bin file
        
    Returns:
        Software ID string (e.g., 'I8A0S') or None if not detected
    """
    # Search first 256KB for software ID pattern
    search_size = min(256 * 1024, len(bin_data))
    
    # Known software IDs to look for
    known_ids = OffsetDatabase.SUPPORTED_SOFTWARE_IDS
    
    # Search for exact matches
    for sw_id in known_ids:
        sw_bytes = sw_id.encode('ascii')
        if sw_bytes in bin_data[:search_size]:
            return sw_id
    
    # Pattern-based search: [IJ][A-Z0-9]{3}S
    # Example: I8A0S, INA0S, IJE0S, IKM0S
    import re
    pattern = rb'[IJ][A-Z0-9]{3}S'
    
    for match in re.finditer(pattern, bin_data[:search_size]):
        sw_id = match.group(0).decode('ascii')
        # Verify it's a real software ID by checking if it appears multiple times
        if bin_data[:search_size].count(match.group(0)) >= 2:
            return sw_id
    
    return None


# Global database instance
_offset_db = None

def get_offset_database() -> OffsetDatabase:
    """
    Get singleton instance of offset database.
    
    Returns:
        OffsetDatabase instance
    """
    global _offset_db
    if _offset_db is None:
        _offset_db = OffsetDatabase()
    return _offset_db


# Convenience functions for backward compatibility
def get_vmax_offsets(software_id: str) -> List[int]:
    """Get VMAX offset addresses for software version."""
    db = get_offset_database()
    entries = db.get_vmax_offsets(software_id)
    return [e.offset for e in entries]


def get_rev_limiter_offsets(software_id: str) -> List[int]:
    """Get rev limiter offset addresses for software version."""
    db = get_offset_database()
    entries = db.get_rev_limiter_offsets(software_id)
    return [e.offset for e in entries]


def get_dtc_offsets(software_id: str) -> List[int]:
    """Get DTC offset addresses for software version."""
    db = get_offset_database()
    entries = db.get_dtc_offsets(software_id)
    return [e.offset for e in entries]


if __name__ == '__main__':
    # Test the database
    print("=" * 80)
    print("BMW N54 Offset Database Test")
    print("=" * 80)
    
    db = get_offset_database()
    
    print(f"\nSupported Software IDs: {', '.join(db.SUPPORTED_SOFTWARE_IDS)}")
    
    # Test each software ID
    for sw_id in db.SUPPORTED_SOFTWARE_IDS:
        print(f"\n--- {sw_id} ---")
        
        vmax = db.get_vmax_offsets(sw_id)
        print(f"VMAX offsets: {len(vmax)} tables")
        for entry in vmax:
            print(f"  0x{entry.offset:06X}: {entry.title} ({entry.size_bytes} bytes)")
        
        rev = db.get_rev_limiter_offsets(sw_id)
        print(f"Rev Limiter offsets: {len(rev)} tables")
        for entry in rev[:2]:  # Show first 2
            print(f"  0x{entry.offset:06X}: {entry.title} ({entry.size_bytes} bytes)")
    
    # Test comparison
    print(f"\n{'=' * 80}")
    print("Offset Comparison: Speed Limiter (Master)")
    print(f"{'=' * 80}")
    comparison = db.compare_offsets('vmax', 'Speed Limiter (Master)')
    for sw_id, offset in comparison.items():
        if offset:
            print(f"  {sw_id}: 0x{offset:06X}")
        else:
            print(f"  {sw_id}: NOT FOUND")
    
    # Test software ID detection
    print(f"\n{'=' * 80}")
    print("Software ID Detection Test")
    print(f"{'=' * 80}")
    
    test_bins = [
        Path(r'C:\Users\admin\Documents\535xi\maps\reference_bins\I8A0S_original.bin'),
        Path(r'C:\Users\admin\Documents\535xi\maps\reference_bins\INA0S_original.bin'),
    ]
    
    for bin_path in test_bins:
        if bin_path.exists():
            with open(bin_path, 'rb') as f:
                data = bytearray(f.read())
            detected = detect_software_id(data)
            print(f"  {bin_path.name}: {detected}")
